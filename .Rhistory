install.packages("BiocManager")
BiocManager::install(version = "3.10")
n
l
suppressPackageStartupMessages(library(optparse))
suppressPackageStartupMessages(library("devtools"))
suppressPackageStartupMessages(library(dada2))
devtools::install_github("benjjneb/dada2")
suppressPackageStartupMessages(library(ShortRead))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(bayesplot))
suppressPackageStartupMessages(library(ShortRead))
install.packages("S4Vectors")
suppressPackageStartupMessages(library("devtools"))
devtools::install_github("benjjneb/dada2")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("dada2", version = "3.10")
suppressPackageStartupMessages(library(dada2))
suppressPackageStartupMessages(library(ShortRead))
BiocManager::install("BiocGenerics")
suppressPackageStartupMessages(library(dada2))
BiocManager::install("BiocGenerics")
suppressPackageStartupMessages(library(dada2))
BiocManager::install("BiocGenerics", version = "0.22.0")
BiocManager::install("BiocGenerics")
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(bayesplot))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ShortRead))
suppressPackageStartupMessages(library(dada2))
BiocManager::install("dada2", version = "3.10")
suppressPackageStartupMessages(library(dada2))
install.packages("~/Downloads/BiocGenerics_0.32.0.tar.gz", repos = NULL, type = "source")
suppressPackageStartupMessages(library(dada2))
.Platform$GUI
install.packages("languageserver")
install.packages('IRkernel')
IRkernel::installspec(user = FALSE)
install.packages("uuid")
IRkernel::installspec(user = FALSE)
setwd("~/Dropbox/GCB/weibull")
#library(devtools)
#install_github("willpearse/phest")
library(phest)
# -------------- #
# load libraries #
# -------------- #
#library(devtools)
#install_github("willpearse/phest")
library(phest)
library(reshape2)
library(deming)
library(car)
library(devtools)
library(broom)
library(plyr)
library(lme4)
library(phest)
library(lmerTest)
library(dplyr)
library(stringr)
library(ggplot2)
library(knitr)
library(kableExtra)
source(file.path("./weibull.R")) # Pearse et al. github.com code for repo "phest"
source(file.path("./iler_functions.R")) # Iler et al. custom functions
# load data
data <- na.omit(read.csv("../data/rmbl_data_de-dup.csv"))
# rename some headers; make all lowercase
names(data)[4] <- "flowers"
names(data) <- tolower(names(data))
# subset data to include only years after 1973
data <- subset(data, year > "1973")
min_years = 19
pseudoreplicate = TRUE
x = data
head(x)
stopifnot(all(c("doy", "species", "year", "plot") %in% names(x)))
head(data)
#! determine species present with sufficient numbers of years' worth of data to include
counts <- apply(
tapply(x$doy, list(x$species, x$year), function(x) length(x) > 0),
1,
function(x) sum(x, na.rm=TRUE) >= min_years)
counts
tapply(x$doy, list(x$species, x$year), function(x) length(x) > 0)
#! determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)))
dat = data
#! determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)))
#! determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) %>%
c()
#! determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) %>%
as.vector()
#! determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species)
#! determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) ->
species_to_include
#! filter data to species present in >= min_years
dat %>%
dplyr::filter(species %in% species_to_include$species) ->
dat_filt
dat_filt
head(dat)
dat_filt[dat_filt$flowers == 0, ]
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
dat %>%
dplyr::filter(species %in% species_to_include$species,
flower > 0) ->
dat_filt
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flower > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flowers > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
replicate_dates
replicate_dates = FALSE
?slice
if (replicate_dates == TRUE) {
dat_filt <- do.call(rbind,
apply(dat_filt,
1,
function(x) sapply(x[-4],
function(y) rep(y, x[4]))
)
)
}
dim(dat_filt)
dim(dat)
head(dat)
replicate_dates
replicate_dates = TRUE
# date-replication step
# each row is replicated as many times as there were counts of flowers
# for a given observation day for a species-plot-year combination.
# Note that hard-coded is that col index 4 equals 'flowers'.
if (replicate_dates == TRUE) {
dat_filt_copy <- dat_filt
dat_filt <- do.call(rbind,
apply(dat_filt,
1,
function(x) sapply(x[-4],
function(y) rep(y, x[4]))
)
)
}
dim(dat_filt)
sum(dat_filt_copy$flowers)
dat_filt
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flowers > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flowers > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
dat_filt_copy <- dat_filt
dat_filt_copy[1:10, ]
dim(dat_filt)
dim(dat_filt[drop.duplicates(dat_filt), ])
dim(unique(dat_filt))
# ensure each row is unique
dat_filt <- unique(dat_filt)
?split
dat_filt_copy[1:10, ] %>%
apply(., 1, function(x) rep(x, x[["flowers"]])) ->
test_dup
test_dup
test_dup %>% do.call(rbind, .)
dat_filt_copy
split(dat_filt_copy, row.names(dat_filt_copy))
dat_filt_copy[1:10, ] %>%
split(., rownames(.))
dat_filt_copy <- dat_filt
dat_filt_copy[1:10, ] -> x
x
dat_filt_copy[1:10, ] %>%
split(., rownames(.)) -> x
x
x[[1]]
x[[1]] %>% function(x) x
x[[1]] %>% (function(x) x)
x[[1]] %>% (function(x) rep(x, x[["flowers"]]))
x[[1]] %>% (function(x) data.frame(rep(x, x[["flowers"]])))
x[[1]] %>% (function(x) data.frame(rep(x[-4], x[["flowers"]])))
x[[1]] %>% (function(x) data.frame(rep(x, x[["flowers"]])))
dat_filt_copy[1:10, ] %>%
split(., rownames(.)) %>%
lapply(., function(x) data.frame(rep(x, x[["flowers"]]))) ->
dat_replicated
dat_replicated
dat_filt_copy[1:100, ] %>%
split(., rownames(.)) %>%
lapply(., function(x) data.frame(rep(x, x[["flowers"]]))) ->
dat_replicated
head(dat_replicated)
tail(dat_replicated)
dat_filt_copy %>%
dplyr::filter(flowers > 1) %>%
head() %>%
split(., rownames(.)) %>%
lapply(., function(x) data.frame(rep(x, x[["flowers"]]))) ->
dat_replicated
dat_replicated
dat_filt_copy %>%
dplyr::filter(flowers > 1) %>%
head() %>%
split(., rownames(.)) %>%
lapply(., function(x) rep(x, x[["flowers"]])) ->
dat_replicated
dat_replicated
?rep
row.names(dat_filt)
idx <- row.names(dat_filt)
rep_vec <- dat_filt$flowers
idx_rep <- rep(idx, rep_vec)
dim(idx_rep)
length(idx_rep)
sum(dat_filt$flowers)
length(unique(idx))
length(idx)
dat_rep <- dat_filt[idx_rep, ]
dim(dat_rep
)
sum(dat_filt$flowers)
stopifnot(dim(dat_rep)[1] == dim(dat_filt)[1])
stopifnot(dim(dat_rep)[1] == sum(dat_filt$flowers))
replicate_dates <- function(df) {
idx <- row.names(df)
rep_vec <- df$flowers
idx_rep <- rep(idx, rep_vec)
df_rep <- df[idx_rep, ]
stopifnot(dim(df_rep)[1] == sum(df$flowers))
return(df_rep)
}
stopifnot("flowers" %in% names(df))
replicate_dates <- function(df) {
stopifnot("flowers" %in% names(df))
idx <- row.names(df)
rep_vec <- df$flowers
idx_rep <- rep(idx, rep_vec)
df_rep <- df[idx_rep, ]
stopifnot(dim(df_rep)[1] == sum(df$flowers))
return(df_rep)
}
# date-replication step
# each row is replicated as many times as there were counts of flowers
# for a given observation day for a species-plot-year combination.
# Note that hard-coded is that col index 4 equals 'flowers'.
if (replicate_dates == TRUE) {
df_filt <- replicate_dates(df_filt)
}
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flowers > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
# ensure each row is unique
dat_filt <- unique(dat_filt)
df <- df_filt
df <- dat_filt
# date-replication step
# each row is replicated as many times as there were counts of flowers
# for a given observation day for a species-plot-year combination.
# Note that hard-coded is that col index 4 equals 'flowers'.
if (replicate_dates == TRUE) {
dat_filt <- replicate_dates(dat_filt)
}
df <- dat_filt
stopifnot("flowers" %in% names(df))
idx <- row.names(df)
rep_vec <- df$flowers
idx_rep <- rep(idx, rep_vec)
df_rep <- df[idx_rep, ]
stopifnot(dim(df_rep)[1] == sum(df$flowers))
replicate_dates <- function(df) {
stopifnot("flowers" %in% names(df))
idx <- row.names(df)
rep_vec <- df$flowers
idx_rep <- rep(idx, rep_vec)
df_rep <- df[idx_rep, ]
stopifnot(dim(df_rep)[1] == sum(df$flowers))
return(df_rep)
}
replicate_dates <- function(df) {
stopifnot("flowers" %in% names(df))
idx <- row.names(df)
rep_vec <- df$flowers
idx_rep <- rep(idx, rep_vec)
df_rep <- df[idx_rep, ]
stopifnot(dim(df_rep)[1] == sum(df$flowers))
return(df_rep)
}
replicate_dates(dat_filt)
replicate_dates
do_replicate_dates <- function(df) {
stopifnot("flowers" %in% names(df))
idx <- row.names(df)
rep_vec <- df$flowers
idx_rep <- rep(idx, rep_vec)
df_rep <- df[idx_rep, ]
stopifnot(dim(df_rep)[1] == sum(df$flowers))
return(df_rep)
}
replicate_dates = TRUE
# date-replication step
# each row is replicated as many times as there were counts of flowers
# for a given observation day for a species-plot-year combination.
# Note that hard-coded is that col index 4 equals 'flowers'.
if (replicate_dates == TRUE) {
dat_filt <- do_replicate_dates(dat_filt)
}
# re-order data.frame
dat_filt <-
dat_filt %>%
dplyr::arrange(species, plot, year, doy)
dat_filt$doy     <- as.numeric(as.character(dat_filt$doy))
dat_filt$year    <- as.numeric(as.character(dat_filt$year))
dat_filt$species <- as.character(dat_filt$species)
str(dat_filt)
dat_filt <- data.frame(dat_filt, stringsAsFactors = FALSE)
str(dat_filt)
names(dat_filt)
stopifnot(all(c("doy", "species", "year", "plot") %in% names(x)))
stopifnot(all(c("doy", "species", "year", "plot") %in% names(dat)))
dat$plot    <- as.character(dat$plot)
dat$species <- as.character(dat$species)
dat$doy     <- as.numeric(as.character(dat$doy))
dat$flowers <- as.numeric(dat$flowers)
dat$year    <- as.numeric(as.character(dat$year))
dat$habitat <- as.character(dat$habitat)
str(dat)
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) ->
species_to_include
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species.groups) ->
species_to_include
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::ungroup() %>%
dplyr::select(species) ->
species_to_include
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year))) %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) %>%
dplyr::ungroup() ->
species_to_include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)))
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)), .groups = "drop") %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) ->
species_to_include
species_to_include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)), .groups = "drop") %>%
dplyr::filter(n_years >= min_years)
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)), .groups = "drop") %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) ->
species_to_include
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flowers > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
# ensure each row is unique
dat_filt <- unique(dat_filt)
replicate_dates
# date-replication step
# each row is replicated as many times as there were counts of flowers
# for a given observation day for a species-plot-year combination.
# Note that hard-coded is that col index 4 equals 'flowers'.
if (replicate_dates == TRUE) {
dat_filt <- do_replicate_dates(dat_filt)
}
# re-order data.frame
dat_filt <-
dat_filt %>%
dplyr::arrange(species, plot, year, doy)
str(dat_filt)
preprocess_data <- function(dat, min_years = 19, replicate_dates = FALSE) {
stopifnot(all(c("doy", "species", "year", "plot") %in% names(dat)))
# ensure columns are correct data type
dat$plot    <- as.character(dat$plot)
dat$species <- as.character(dat$species)
dat$doy     <- as.numeric(as.character(dat$doy))
dat$flowers <- as.numeric(dat$flowers)
dat$year    <- as.numeric(as.character(dat$year))
dat$habitat <- as.character(dat$habitat)
# determine species present with sufficient numbers of years' worth of data to include
dat %>%
dplyr::group_by(species) %>%
dplyr::summarise(n_years = length(unique(year)), .groups = "drop") %>%
dplyr::filter(n_years >= min_years) %>%
dplyr::select(species) ->
species_to_include
# filter data to species present in >= min_years
# AND ensure all records have > 0 flowers
# AND ensure flowers is int
dat %>%
dplyr::filter(species %in% species_to_include$species,
flowers > 0) %>%
dplyr::mutate(flowers = round(flowers)) ->
dat_filt
# ensure each row is unique
dat_filt <- unique(dat_filt)
# date-replication step
# each row is replicated as many times as there were counts of flowers
# for a given observation day for a species-plot-year combination.
# Note that hard-coded is that col index 4 equals 'flowers'.
if (replicate_dates == TRUE) {
dat_filt <- do_replicate_dates(dat_filt)
}
# re-order data.frame
dat_filt <-
dat_filt %>%
dplyr::arrange(species, plot, year, doy)
return(dat_filt)
}
# load data
data <- na.omit(read.csv("../data/rmbl_data_de-dup.csv"))
# rename some headers; make all lowercase
names(data)[4] <- "flowers"
names(data) <- tolower(names(data))
# subset data to include only years after 1973
data <- subset(data, year > "1973")
# Process data in two ways:
# first WITH flower-fold pseudoreplication of each species-year-plot-doy in data
# second WITHOUT this step
data_dup   <- preprocess_data(data, min_years = 19, replicate_dates = TRUE)
data_dedup <- preprocess_data(data, min_years = 19, replicate_dates = FALSE)
# run estimates with and without plot-level aggregation using pseudo-replicated and deduplicated input data
# use Pearse et al. (2017) default k_min
# pseudoreplicated input data
thetas_plot_dup     <- calc_weibull_pearse(data_dup, by_plot = TRUE,  k_min = 10)
