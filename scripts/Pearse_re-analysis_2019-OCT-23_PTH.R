
rm(list = ls(all = TRUE))


#head(merge.results)


# THE BELOW MIGHT BE OBSOLETE, DEPENDING ON WHETHER IT CORRESPONDS TO THE FUNCTION ROUTINE IN ILER_FUNCTIONS

# add flower abundance data to corrected.results data.frame
sum.data <- ddply(data,
                  .(species, year, doy),
                  summarize,
                  sum.flws = sum(flowers)) # sum flowers across plots on each date to get peak #flowers for each species in each year

peak.abundance.data <- ddply(sum.data,
                             .(year, species),
                             summarize,
                             peak.flowers = max(sum.flws))

results.corrected <- results.corrected[order(results.corrected$year, results.corrected$species), ] # now both data.frames are sorted by year then species

sum.data <-
  data %>%
  dplyr::group_by(species, year, doy) %>%
  dplyr::summarise(sum.flws = sum(flowers)) %>%
  dplyr::group_by(year, species) %>%
  dplyr::summarise(peak.flowers = max(sum.flws))

merge.results <-
  results.corrected %>%
  dplyr::left_join(sum.data, by = c('species', 'year'))



# run the models


### repeat Deming regressions with shifts from model with all species and flower abundance covariate ###

# first vs. peak


# produce plots of the Deming regression results:

##################################################################################
##                                                                              ##
##         ~~  CODE FOR PEARSE ET AL. (2017), FROM W. PEARSE  ~~                ##
##                                                                              ##
##################################################################################

#Modelling Rocky Mountain data

#! Comments added by Will Pearse 2018-07-09. This is the analysis
#! script, with some additional comments (to explain) and some file
#! load path/name changes.
#! Comments added afterwards have "#!" at the start of them, not "#"

#! This became the released code in the manuscript. Original path/filename: "../code/headers.R"
source("./2018-07-09_headers.R")

#Load data
#! This came from a file called "phenology data_1973_2012 from Amy
#! Iler.xlsx".
#data <- na.omit(read.csv("amy_iler_sheet2.csv"))
counts <- apply(with(data, tapply(doy, list(species, year), function(x) length(x) > 0)), 1, function(x) sum(x, na.rm=TRUE) >= 19)
data <- data[data$species %in% names(counts)[counts==TRUE],]
data <- data[order(data$species, data$plot, data$year, data$doy),]
data <- data[data$n.flowers >= 1,]
data$n.flowers <- round(data$n.flowers)
data <- do.call(rbind, apply(data, 1, function(x) sapply(x[-4], function(y) rep(y, x[4]))))

#! This is where Pearse et al. replicate each entry
#! calculate by how much:
fold_replication <- dim(data)[1] / dim(unique(data))[1] #! factor of 23-fold longer data.frame

data <-
  data %>%
  as.data.frame() %>%
  dplyr::arrange(species, plot, year, doy)

data$doy <- as.numeric(as.character(data$doy))
data$year <- as.numeric(as.character(data$year))
data$species <- as.character(data$species)

#! dedup data and run through same routine:
data_dedup <- unique(data)

#Calculate everything
rm(theta,min,max,mean,median,year,species,theta.end)

#! RE-GENERATE RESULTS WITH DATA_DEDUP
theta <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) theta.hat(x,k=30) else NA)))
theta.end <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) theta.hat(x,k=30,TRUE) else NA)))
min <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) min(x) else NA)))
max <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) max(x) else NA)))
mean <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) mean(x,na.rm=TRUE) else NA)))
median <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) median(x,na.rm=TRUE) else NA)))
abundance <- as.numeric(with(data_dedup, tapply(doy, list(species, plot, year), function(x) if(length(x) > 10) max(table(x)) else NA)))
species <- as.character(with(data_dedup, tapply(species, list(species, plot, year), unique)))
year <- as.numeric(with(data_dedup, tapply(year, list(species, plot, year), unique)))
results <- na.omit(data.frame(theta, theta.end, min, max, mean, species, year, median, abundance))
results$orig.year <- results$year
results$year <- as.numeric(scale(results$year))
results_dedup <- results[results$species %in% names(Filter(function(x) x > 10, table(results$species))),]
rm(theta,min,max,mean,median,year,species,theta.end)

#! compare results_dup with results_dedup
#! another effect is that when year is re-scaled it is done incorrectly because of the duplicated rows
#! Check how many estimates per species-year were generated by the routine above:
results_dup %>%
  dplyr::group_by(species, orig.year) %>%
  dplyr::summarise(n_theta = n()) %>%
  dplyr::arrange(species, orig.year) ->
  n_thetas_dup

results_dedup %>%
  dplyr::group_by(species, orig.year) %>%
  dplyr::summarise(n_theta = n()) %>%
  dplyr::arrange(species, orig.year) ->
  n_thetas_dedup

#! they're totally different numbers of estimates.
#! I need to check whether, if done correctly, it makes a huge difference.
#! combine data.frames to compare
results_dup %>%
  dplyr::group_by(species, orig.year) %>%
  dplyr::summarise(n_theta = n(),
                   mean_theta = mean(theta, na.rm = T),
                   sd_theta   = sd(theta, na.rm = T)) ->
  results_dup2

results_dedup %>%
  dplyr::group_by(species, orig.year) %>%
  dplyr::summarise(n_theta = n(),
                   mean_theta = mean(theta, na.rm = T),
                   sd_theta   = sd(theta, na.rm = T)) ->
  results_dedup2

res_comp <-
  dplyr::full_join(results_dup2,results_dedup2, by = c('species','orig.year'))

# plot:
res_comp %>%
  ggplot(aes(x = mean_theta.x, y = mean_theta.y)) +
  geom_point(alpha = 0.33) +
  geom_abline(slope = 1, intercept = 0) +
  coord_cartesian(xlim = c(-100,300), ylim = c(-100,300)) +
  theme_bw()

# plot difference
res_comp %>%
  dplyr::mutate(theta_diff = mean_theta.y - mean_theta.x) ->
  res_comp

# re-plot
res_comp %>%
  ggplot(aes(x = theta_diff)) +
  geom_histogram(bins = 100, alpha = 0.66) +
  theme_bw() +
  scale_x_continuous(limits = c(-50, 50)) +
  geom_vline(xintercept = 0)

# systematic bias towards later first flowering date with the pseudo-replication


#Modelling
mean.model  <- lm(mean  ~ species * year + log(abundance), data = results)
theta.model <- lm(theta ~ species * year + log(abundance), data = results)
theta.end.model <- lm(theta.end ~ species * year + log(abundance), data=results)

#...logging doesn't do much to model fit, but it makes abundance
#   matter more (--> conservative?) and it looks like it should be logged

# OLD coefficient code (Amy added annotation here)
coefs_P1 <- with(results, as.data.frame(cbind(
  summary(lm(theta ~ species:orig.year + log(abundance)))$coefficients[-1:-2,1:2],
  summary(lm(mean ~ species:orig.year + log(abundance)))$coefficients[-1:-2,1:2],
  summary(lm(theta.end ~ species:orig.year + log(abundance)))$coefficients[-1:-2,1:2]
)))

# CORRECTED coefficient code (Amy added annotation here)
coefs_P2 <- with(results, as.data.frame(cbind(
  summary(lm(theta ~ species+species:orig.year + log(abundance)-1))$coefficients[-1:-66,1:2],
  summary(lm(mean ~ species+species:orig.year + log(abundance)-1))$coefficients[-1:-66,1:2],
  summary(lm(theta.end ~ species+species:orig.year + log(abundance)-1))$coefficients[-1:-66,1:2]
)))

coefs_P1$species <- unique(results$species)
coefs_P2$species <- unique(results$species)

names(coefs_P1)[1:6] <- c("start", "start.se", "bulk", "bulk.se", "end", "end.se")
names(coefs_P2)[1:6] <- c("start", "start.se", "bulk", "bulk.se", "end", "end.se")

#...undo the scaling of year...
#coefs$start <- coefs$start / sd(orig.year)

# Deming Regressions (Amy added this part)

# first vs. peak
d.fvp2 <- deming(coefs_P2$bulk ~ coefs_P2$start, xstd = coefs_P2$start.se, ystd = coefs_P2$bulk.se)

# first vs. end
d.fve2 <- deming(coefs_P2$end ~ coefs_P2$start, xstd = coefs_P2$start.se, ystd = coefs_P2$end.se)

# peak vs. first
d.pvf2 <- deming(coefs_P2$start ~ coefs_P2$bulk, xstd = coefs_P2$bulk.se, ystd = coefs_P2$start.se)

# peak vs. end
d.pve2 <- deming(coefs_P2$end ~ coefs_P2$bulk, xstd = coefs_P2$bulk.se, ystd = coefs_P2$end.se)

list(d.fvp2,
     d.fve2,
     d.pvf2,
     d.pve2) -> dl2

names(dl2) <- c('first_v_peak',
                'first_v_end',
                'peak_v_first',
                'peak_v_end')

dl2.coefs <- lapply(dl2, function(x) data.frame(x$coefficients,x$ci))

for (i in seq_along(dl2.coefs)) {
  dl2.coefs[[i]]$model <- names(dl2)[i]
}

dl2.coefs <-
  dl2.coefs %>%
  do.call(rbind, .)

names(dl2.coefs)[1] <- c('estimate')
dl2.coefs$term <- 'slope'
dl2.coefs$term[grep('Intercept', row.names(dl2.coefs))] <- 'intercept'

write.table(dl2.coefs,
            file = '../output/deming_reg_coefs_Pearse.csv',
            quote = F,
            sep = ',',
            row.names = F,
            col.names = T)

# plotting the coefficient estimates from Deming regressions against one another:
all_coefs <-
  dplyr::left_join(dl1.coefs,dl2.coefs, by = c('model','term'))

# plot coefficient estimates from both approaches
all_coefs %>%
  dplyr::filter(term == 'slope') %>%
  ggplot() +
  geom_abline(slope = 1, intercept = 0, col = 'gray40', lty = 1, lwd = 0.25) +
  geom_hline(yintercept = 1, lty = 1, col = 'gray40', lwd = 0.25) +
  geom_vline(xintercept = 1, lty = 1, col = 'gray40', lwd = 0.25) +
  geom_errorbarh(aes(y = estimate.y,
                    xmin = lower.0.95.x,
                    xmax = upper.0.95.x, col = model), alpha = 0.5) +
  geom_errorbar(aes(x = estimate.x,
                    ymin = lower.0.95.y,
                    ymax = upper.0.95.y, col = model), width = 0, alpha = 0.5) +
  geom_point(aes(x = estimate.x, y = estimate.y, col = model), alpha = 0.5) +
  coord_cartesian(xlim = c(0.4,2.1),
                  ylim = c(0.4,2.1)) +
  xlab('Iler estimates') +
  ylab('Pearse estimates') +
  theme_bw() -> p1

ggsave(p1,
       filename = 'coef_comparison.png',
       width = 4,
       height = 3,
       units = 'in',
       device = 'png',
       dpi = 300
)

################################################################################
##                                                                            ##
##  ~~  COMPARING THETA ESTIMATES BTWN Pearse et al. and Iler re-analysis  ~~ ##
##                                                                            ##
################################################################################

all_comb <- dplyr::left_join(
  dplyr::select(all.data,species,orig.year,theta = onset, theta.end = end, onset.obs = min.doy, end.obs = max.doy),
  dplyr::select(results,species,orig.year,theta,theta.end, onset.obs = min, end.obs = max),
  by = c('species','orig.year')) %>%
  dplyr::filter(theta.y > 0)

# plot
all_comb %>%
  ggplot() +
  geom_point(aes(x = theta.x, y = theta.y), alpha = 0.1, col = 'black') +
  theme_bw() +
  coord_cartesian(xlim = c(50,260),
                  ylim = c(50,260)) +
  xlab(TeX("$\\theta_{start}$  Iler")) +
  ylab(TeX("$\\theta_{start}$  Pearse")) ->
  theta_start_plot

all_comb %>%
  ggplot() +
  geom_point(aes(x = theta.end.x, y = theta.end.y), alpha = 0.1, col = 'black') +
  theme_bw() +
  coord_cartesian(xlim = c(100,350),
                  ylim = c(100,350)) +
  xlab(TeX("$\\theta_{end}$  Iler")) +
  ylab(TeX("$\\theta_{end}$  Pearse")) ->
  theta_end_plot

ggpubr::ggarrange(plotlist = list(theta_start_plot,theta_end_plot), labels = c('a','b'),
                  ncol = 2) %>%
  ggsave(filename = '../output/theta_comps.png',
         width = 6,
         height = 3,
         units = 'in',
         device = 'png',
         dpi = 300)

# # now plot difference between estimated and observed onset and end
# all_comb %>%
#   ggplot() +
#   geom_histogram(aes(x = onset.obs.x - theta.x), bins = 100) +
#   theme_bw() +
#   xlab(TeX("$\\theta_{start} - t_{obs}$  Iler"))
#
# all_comb %>%
#   ggplot() +
#   geom_histogram(aes(x = onset.obs.y - theta.y), bins = 100) +
#   theme_bw() +
#   xlab(TeX("$\\theta_{start} - t_{obs}$  Pearse"))
